/*
          # [Initial Schema Setup]
          This script sets up the initial database schema for the Pirate.Exchange application, including user profiles, roles, application configuration, and exchange pairs. It also enables Row Level Security (RLS) and defines policies to secure the data.

          ## Query Description: [This operation will create new tables and policies. It is designed to run on a new or empty database and is not expected to cause data loss. However, it's always best to have a backup if you are applying this to a project with existing data.]
          
          ## Metadata:
          - Schema-Category: "Structural"
          - Impact-Level: "Medium"
          - Requires-Backup: false
          - Reversible: false
          
          ## Structure Details:
          - Tables Created: `profiles`, `roles`, `user_roles`, `app_config`, `exchange_pairs`
          - Triggers Created: `on_auth_user_created` to create user profiles automatically.
          - RLS Policies: Policies for all new tables to restrict access based on user roles.
          
          ## Security Implications:
          - RLS Status: Enabled on all new tables.
          - Policy Changes: Yes, new policies are created.
          - Auth Requirements: Policies differentiate between anonymous users, authenticated users, and admins.
          
          ## Performance Impact:
          - Indexes: Primary keys and foreign keys are indexed.
          - Triggers: One trigger is added to handle profile creation.
          - Estimated Impact: Low performance impact on a new database.
          */

-- 1. PROFILES TABLE
-- Stores public user information.
CREATE TABLE public.profiles (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    username TEXT UNIQUE,
    full_name TEXT,
    avatar_url TEXT,
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

COMMENT ON TABLE public.profiles IS 'Public profile information for each user.';

-- 2. ROLES TABLE
-- Stores the available roles in the application.
CREATE TABLE public.roles (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT UNIQUE NOT NULL
);

COMMENT ON TABLE public.roles IS 'Defines user roles like admin or member.';

-- 3. USER_ROLES TABLE
-- A join table to assign roles to users.
CREATE TABLE public.user_roles (
    user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    role_id BIGINT NOT NULL REFERENCES public.roles(id) ON DELETE CASCADE,
    PRIMARY KEY (user_id, role_id)
);

COMMENT ON TABLE public.user_roles IS 'Assigns roles to users.';

-- 4. APP_CONFIG TABLE
-- Stores global application configuration.
CREATE TABLE public.app_config (
    key TEXT PRIMARY KEY,
    value TEXT
);

COMMENT ON TABLE public.app_config IS 'Stores key-value application settings.';

-- 5. EXCHANGE_PAIRS TABLE
-- Stores the exchange pairs and their fees.
CREATE TABLE public.exchange_pairs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    "from" TEXT NOT NULL,
    "to" TEXT NOT NULL,
    fee NUMERIC NOT NULL,
    fee_type TEXT NOT NULL CHECK (fee_type IN ('percentage', 'fixed')),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE("from", "to")
);

COMMENT ON TABLE public.exchange_pairs IS 'Defines available exchange pairs and their fees.';

-- SEED DATA
-- Insert default roles and configuration
INSERT INTO public.roles (name) VALUES ('admin'), ('user');
INSERT INTO public.app_config (key, value) VALUES ('discordInviteUrl', 'https://discord.gg/pirate-exchange');

-- Insert default exchange pairs
INSERT INTO public.exchange_pairs ("from", "to", fee, fee_type) VALUES
('PayPal', 'Crypto', 5, 'percentage'),
('Crypto', 'PayPal', 5, 'percentage'),
('Paysafe', 'Crypto', 8, 'percentage'),
('Crypto', 'Paysafe', 8, 'percentage'),
('INR', 'Crypto', 3, 'percentage'),
('Crypto', 'INR', 3, 'percentage'),
('Bank', 'Crypto', 4, 'percentage'),
('Crypto', 'Bank', 4, 'percentage');


-- HELPER FUNCTION TO CHECK USER ROLE
CREATE OR REPLACE FUNCTION public.is_admin(user_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
    RETURN EXISTS (
        SELECT 1
        FROM public.user_roles ur
        JOIN public.roles r ON ur.role_id = r.id
        WHERE ur.user_id = user_id AND r.name = 'admin'
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-- TRIGGER TO CREATE A PROFILE FOR A NEW USER
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
DECLARE
  admin_role_id BIGINT;
BEGIN
  -- Insert a new profile for the new user
  INSERT INTO public.profiles (id, username)
  VALUES (new.id, new.raw_user_meta_data->>'username');

  -- Check if this is the first user, if so, make them an admin
  IF (SELECT count(*) FROM auth.users) = 1 THEN
    SELECT id INTO admin_role_id FROM public.roles WHERE name = 'admin';
    IF admin_role_id IS NOT NULL THEN
      INSERT INTO public.user_roles (user_id, role_id) VALUES (new.id, admin_role_id);
    END IF;
  END IF;

  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();


-- RLS POLICIES
-- Enable RLS for all tables
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.app_config ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.exchange_pairs ENABLE ROW LEVEL SECURITY;

-- Profiles Policies
CREATE POLICY "Profiles are viewable by everyone." ON public.profiles FOR SELECT USING (true);
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);
CREATE POLICY "Users can update their own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- Roles & User_Roles Policies
CREATE POLICY "Admins can manage roles." ON public.roles FOR ALL USING (public.is_admin(auth.uid())) WITH CHECK (public.is_admin(auth.uid()));
CREATE POLICY "Roles are visible to authenticated users." ON public.roles FOR SELECT USING (auth.role() = 'authenticated');
CREATE POLICY "Admins can manage user_roles." ON public.user_roles FOR ALL USING (public.is_admin(auth.uid())) WITH CHECK (public.is_admin(auth.uid()));
CREATE POLICY "Users can view their own roles." ON public.user_roles FOR SELECT USING (auth.uid() = user_id);

-- App_Config & Exchange_Pairs Policies
CREATE POLICY "Config is visible to everyone." ON public.app_config FOR SELECT USING (true);
CREATE POLICY "Admins can manage app config." ON public.app_config FOR ALL USING (public.is_admin(auth.uid())) WITH CHECK (public.is_admin(auth.uid()));

CREATE POLICY "Exchange pairs are visible to everyone." ON public.exchange_pairs FOR SELECT USING (true);
CREATE POLICY "Admins can manage exchange pairs." ON public.exchange_pairs FOR ALL USING (public.is_admin(auth.uid())) WITH CHECK (public.is_admin(auth.uid()));
